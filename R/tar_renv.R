#' @title Set up package dependencies for compatibility with `renv`
#' @export
#' @seealso <https://rstudio.github.io/renv/articles/renv.html>
#' @description Write package dependencies to a script file
#'   (by default, named `_packages.R` in the root project directory).
#'   Each package is written to a separate line
#'   as a standard [library()] call (e.g. `library(package)`) so
#'   `renv` can identify them automatically.
#'
#'   This function tries to identify package dependencies that would be
#'   hidden to `renv` because they are declared using the `targets` API.
#'   Thus, this is only necessary if using [`tar_option_set()`] or
#'   [`tar_target()`] to use specialized storage formats or manage packages,
#'   rather than the usual `library()` or namespaced call
#'   (i.e. `package::function()`). See `Details` for more information.
#' @details This function gets called for its side-effect, which writes
#'   package dependencies to a script. The generated file should __not__ be
#'   edited by hand and will be overwritten each time `tar_renv()` runs
#'   non-interactively.
#'
#'   With the script written by `tar_renv()`, `renv` is able to crawl the
#'   file to identify package dependencies (with `renv::dependencies()`).
#'   Calling `renv::init()` after `tar_renv()` has ran will set up a
#'   project-local `R` library. This allows your `targets` pipeline to have
#'   its own self-contained `R` library separate from your standard `R`
#'   library. See <https://rstudio.github.io/renv/index.html> for
#'   more information.
#' @return Nothing, invisibly.
#' @inheritParams tar_prune
#' @param extras Character vector of additional packages to declare as
#'   project dependencies.
#' @param path Character of length 1, path to the script file to
#'   populate with `library()` calls.
#' @examples
#' tar_dir({
#'   tar_script({
#'     tar_option_set(packages = c("tibble", "qs"))
#'     tar_pipeline()
#'   })
#'   tar_renv()
#'   readLines("_packages.R")
#' })
tar_renv <- function(
  extras = c("clustermq", "future", "rstudioapi", "visNetwork"),
  path = "_packages.R",
  callr_function = callr::r,
  callr_arguments = list()
) {
  assert_target_script()
  assert_chr(extras, "extras must be a character vector")
  assert_chr(path, "path must have type character")
  assert_scalar(path, "path must have length 1")
  assert_callr_function(callr_function)
  assert_list(callr_arguments, "callr_arguments must be a list.")
  callr_outer(
    targets_function = tar_renv_inner,
    targets_arguments = list(extras = extras, path = path),
    callr_function = callr_function,
    callr_arguments = callr_arguments
  )
  invisible()
}

tar_renv_inner <- function(pipeline, extras, path) {
  pipeline_validate_lite(pipeline)
  option_pkgs <- tar_option_get("packages")
  targets_pkgs <- pipeline_get_packages(pipeline)
  option_format <- store_get_packages(store_init(tar_option_get("format")))
  targets_formats <- pipeline_get_formats(pipeline)
  targets_formats <- map(targets_formats, ~store_get_packages(store_init(.)))
  targets_formats <- unlist(targets_formats)
  all_pkgs <- unique(c(option_pkgs, targets_pkgs, option_format,
                       targets_formats, extras))
  all_pkgs <- sort(all_pkgs)
  lines <- c(
    "# Generated by targets::tar_renv(): do not edit by hand",
    paste0("library(", all_pkgs, ")")
  )
  writeLines(lines, con = path)
}
