% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_watch.R
\name{tar_watch}
\alias{tar_watch}
\title{Shiny app to watch the dependency graph.}
\usage{
tar_watch(
  seconds = 5,
  seconds_min = 1,
  seconds_max = 100,
  seconds_step = 1,
  targets_only = FALSE,
  outdated = TRUE,
  label = NULL,
  level_separation = 150,
  height = "700px",
  background = TRUE,
  browse = TRUE,
  host = getOption("shiny.host", "127.0.0.1"),
  port = getOption("shiny.port", targets::tar_random_port()),
  verbose = TRUE
)
}
\arguments{
\item{seconds}{Numeric of length 1,
default number of seconds between refreshes of the graph.
Can be changed in the app controls.}

\item{seconds_min}{Numeric of length 1, lower bound of \code{seconds}
in the app controls.}

\item{seconds_max}{Numeric of length 1, upper bound of \code{seconds}
in the app controls.}

\item{seconds_step}{Numeric of length 1, step size of \code{seconds}
in the app controls.}

\item{targets_only}{Logical, whether to restrict the output to just targets
(\code{FALSE}) or to also include imported global functions and objects.}

\item{outdated}{Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting \code{outdated} to \code{FALSE} is a nice way to speed up the graph
if you only want to see dependency relationships and build progress.}

\item{label}{Label argument to \code{\link[=tar_visnetwork]{tar_visnetwork()}}.}

\item{level_separation}{Numeric of length 1,
\code{levelSeparation} argument of \code{visNetwork::visHierarchicalLayout()}.
Controls the distance between hierarchical levels.
Consider changing the value if the aspect ratio of the graph
is far from 1. If \code{level_separation} is \code{NULL},
the \code{levelSeparation} argument of \code{visHierarchicalLayout()}
defaults to \code{150}.}

\item{height}{Character of length 1,
height of the \code{visNetwork} widget.}

\item{background}{Logical, whether to run the app in a background process
so you can still use the R console while the app is running.}

\item{browse}{Whether to open the app in a browser when the app is ready.
Only relevant if \code{background} is \code{TRUE}.}

\item{host}{Character of length 1, IPv4 address to listen on.
Only relevant if \code{background} is \code{TRUE}.}

\item{port}{Positive integer of length 1, TCP port to listen on.
Only relevant if \code{background} is \code{TRUE}.}

\item{verbose}{whether to print a spinner and informative messages.
Only relevant if \code{background} is \code{TRUE}.}
}
\value{
A handle to \code{callr::r_bg()} background process running the app.
}
\description{
Launches a background process with a Shiny app
that calls \code{\link[=tar_visnetwork]{tar_visnetwork()}} every few seconds.
To embed this app in other apps, use the Shiny module
in \code{\link[=tar_watch_ui]{tar_watch_ui()}} and \code{\link[=tar_watch_server]{tar_watch_server()}}.
}
\details{
The controls of the app are in the left panel.
The \code{seconds} control is the number of seconds between
refreshes of the graph, and the other settings match
the arguments of \code{\link[=tar_visnetwork]{tar_visnetwork()}}.
}
\examples{
if (identical(Sys.getenv("TARGETS_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # Write all files to a temporary directory.
tar_script({
  sleep_run <- function(...) {
    Sys.sleep(10)
  }
  list(
    tar_target(settings, sleep_run()),
    tar_target(data1, sleep_run(settings)),
    tar_target(data2, sleep_run(settings)),
    tar_target(data3, sleep_run(settings)),
    tar_target(model1, sleep_run(data1)),
    tar_target(model2, sleep_run(data2)),
    tar_target(model3, sleep_run(data3)),
    tar_target(figure1, sleep_run(model1)),
    tar_target(figure2, sleep_run(model2)),
    tar_target(figure3, sleep_run(model3)),
    tar_target(conclusions, sleep_run(c(figure1, figure2, figure3)))
  )
})
# Launch the app in a background process.
tar_watch(seconds = 10, outdated = FALSE, targets_only = TRUE)
# Run the pipeline.
tar_make()
})
}
}
